import{az as x,b0 as H,aY as E,aX as R}from"./three.module-2fef69e5.js";function N(e,l=1e-4){l=Math.max(l,Number.EPSILON);const s={},f=e.getIndex(),o=e.getAttribute("position"),m=f?f.count:o.count;let t=0;const u=Object.keys(e.attributes),p={},d={},T=[],X=["getX","getY","getZ","getW"],D=["setX","setY","setZ","setW"];for(let i=0,c=u.length;i<c;i++){const r=u[i],n=e.attributes[r];p[r]=new x(new n.array.constructor(n.count*n.itemSize),n.itemSize,n.normalized);const a=e.morphAttributes[r];a&&(d[r]=new x(new a.array.constructor(a.count*a.itemSize),a.itemSize,a.normalized))}const G=Math.log10(1/l),U=Math.pow(10,G);for(let i=0;i<m;i++){const c=f?f.getX(i):i;let r="";for(let n=0,a=u.length;n<a;n++){const h=u[n],g=e.getAttribute(h),b=g.itemSize;for(let w=0;w<b;w++)r+=`${~~(g[X[w]](c)*U)},`}if(r in s)T.push(s[r]);else{for(let n=0,a=u.length;n<a;n++){const h=u[n],g=e.getAttribute(h),b=e.morphAttributes[h],w=g.itemSize,B=p[h],j=d[h];for(let A=0;A<w;A++){const I=X[A],M=D[A];if(B[M](t,g[I](c)),b)for(let S=0,k=b.length;S<k;S++)j[S][M](t,b[S][I](c))}}s[r]=t,T.push(t),t++}}const z=e.clone();for(const i in e.attributes){const c=p[i];if(z.setAttribute(i,new x(c.array.slice(0,t*c.itemSize),c.itemSize,c.normalized)),i in d)for(let r=0;r<d[i].length;r++){const n=d[i][r];z.morphAttributes[i][r]=new x(n.array.slice(0,t*n.itemSize),n.itemSize,n.normalized)}}return z.setIndex(T),z}function O(e,l){if(l===H)return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."),e;if(l===E||l===R){let s=e.getIndex();if(s===null){const t=[],u=e.getAttribute("position");if(u!==void 0){for(let p=0;p<u.count;p++)t.push(p);e.setIndex(t),s=e.getIndex()}else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),e}const f=s.count-2,o=[];if(l===E)for(let t=1;t<=f;t++)o.push(s.getX(0)),o.push(s.getX(t)),o.push(s.getX(t+1));else for(let t=0;t<f;t++)t%2===0?(o.push(s.getX(t)),o.push(s.getX(t+1)),o.push(s.getX(t+2))):(o.push(s.getX(t+2)),o.push(s.getX(t+1)),o.push(s.getX(t)));o.length/3!==f&&console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");const m=e.clone();return m.setIndex(o),m.clearGroups(),m}else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",l),e}export{N as m,O as t};
